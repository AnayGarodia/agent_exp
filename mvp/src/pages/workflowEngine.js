// ---------------------------------------------------------------------------
// WorkflowExecutor
// Runs the JavaScript code generated by Blockly, providing Gmail and AI
// functions as a sandboxed execution context.
// ---------------------------------------------------------------------------

export class WorkflowExecutor {
  constructor() {
    this.inputData = {};
    this.variables = {};
    this.output = [];
    this.gmailConnected = false;
    this.onOutput = null;
    this.onGmailRequired = null;
  }

  setInputData(data) {
    this.inputData = data;
    this.variables = { ...data };
  }

  setGmailStatus(connected) {
    this.gmailConnected = connected;
  }

  setGmailRequiredCallback(callback) {
    this.onGmailRequired = callback;
  }

  // -------------------------------------------------------------------------
  // OUTPUT
  // -------------------------------------------------------------------------

  addOutput(type, content, metadata = {}) {
    const item = {
      type,
      content,
      timestamp: new Date().toISOString(),
      ...metadata,
    };

    this.output.push(item);

    if (this.onOutput) {
      this.onOutput([...this.output]);
    }

    console.log(`[${type.toUpperCase()}]`, content);
    return item;
  }

  // -------------------------------------------------------------------------
  // GMAIL GUARD
  // -------------------------------------------------------------------------

  async ensureGmailConnected() {
    if (this.gmailConnected) return;

    this.addOutput("warning", "Gmail connection required.");

    if (this.onGmailRequired) {
      await this.onGmailRequired();

      const timeout = 30000;
      const start = Date.now();
      while (!this.gmailConnected && Date.now() - start < timeout) {
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }

    if (!this.gmailConnected) {
      throw new Error(
        "Gmail not connected. Please connect your Gmail account."
      );
    }
  }

  async checkGmailConnection() {
    try {
      const response = await fetch("http://localhost:3001/api/gmail/status");
      const data = await response.json();
      this.gmailConnected = data.connected;
      return data.connected;
    } catch (err) {
      console.error("[engine] Gmail status check failed:", err.message);
      return false;
    }
  }

  // -------------------------------------------------------------------------
  // GMAIL — READ
  // -------------------------------------------------------------------------

  async fetchUnreadEmails(max = 10) {
    await this.ensureGmailConnected();
    this.addOutput("log", "Fetching unread emails...");

    try {
      const response = await fetch(
        `http://localhost:3001/api/emails/unread?max=${max}`
      );
      const data = await response.json();

      if (data.emails && data.emails.length > 0) {
        this.addOutput(
          "success",
          `Found ${data.emails.length} unread email(s).`,
          {
            count: data.emails.length,
          }
        );

        data.emails.forEach((email, i) => {
          const preview = (email.snippet || email.body || "").substring(0, 100);
          this.addOutput(
            "email-preview",
            `Email ${i + 1}:\n  From: ${email.from}\n  Subject: ${
              email.subject
            }\n  Preview: ${preview}...`,
            { emailData: email }
          );
        });

        return data.emails;
      }

      this.addOutput("info", "No unread emails found.");
      return [];
    } catch (err) {
      this.addOutput("error", `Failed to fetch emails: ${err.message}`);
      throw err;
    }
  }

  async searchEmails(query, max = 10) {
    await this.ensureGmailConnected();
    this.addOutput("log", `Searching emails: "${query}"...`);

    try {
      const params = new URLSearchParams({ q: query, max: String(max) });
      const response = await fetch(
        `http://localhost:3001/api/emails/search?${params}`
      );
      const data = await response.json();

      if (data.emails && data.emails.length > 0) {
        this.addOutput(
          "success",
          `Search found ${data.emails.length} email(s).`,
          {
            count: data.emails.length,
            total: data.total,
          }
        );

        data.emails.forEach((email, i) => {
          const preview = (email.snippet || email.body || "").substring(0, 100);
          this.addOutput(
            "email-preview",
            `Result ${i + 1}:\n  From: ${email.from}\n  Subject: ${
              email.subject
            }\n  Preview: ${preview}...`,
            { emailData: email }
          );
        });

        return data.emails;
      }

      this.addOutput("info", "No emails matched the search.");
      return [];
    } catch (err) {
      this.addOutput("error", `Search failed: ${err.message}`);
      throw err;
    }
  }

  // -------------------------------------------------------------------------
  // GMAIL — SEND
  // -------------------------------------------------------------------------

  async generateAIReply(emailBody, task, subject, from) {
    this.addOutput("log", `Generating AI reply for email from ${from}...`);

    try {
      const response = await fetch("http://localhost:3001/api/ai/reply", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          emailBody,
          task: task || "Draft a professional, helpful email response.",
          subject,
          from,
        }),
      });

      const data = await response.json();

      if (response.ok && data.text) {
        this.addOutput(
          "ai-generated",
          `AI reply generated (${data.text.length} chars):\n\n${data.text}`,
          {
            replyText: data.text,
            length: data.text.length,
            groqApiCalls: data.groqApiCalls,
          }
        );
        return data.text;
      }

      this.addOutput("error", `AI generation failed: ${data.error}`);
      throw new Error(data.error || "AI generation failed.");
    } catch (err) {
      this.addOutput("error", `AI generation error: ${err.message}`);
      throw err;
    }
  }

  async sendEmailReply(emailId, replyBody, subject, to, threadId) {
    await this.ensureGmailConnected();
    this.addOutput("log", `Sending reply to ${to}...`);

    this.addOutput(
      "email-sending",
      `To: ${to}\nSubject: Re: ${subject}\nLength: ${
        (replyBody || "").length
      } chars\n\n${(replyBody || "").substring(0, 200)}...`,
      { to, subject: `Re: ${subject}`, body: replyBody }
    );

    try {
      const response = await fetch("http://localhost:3001/api/emails/send", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ emailId, replyBody, subject, to, threadId }),
      });

      const data = await response.json();

      if (response.ok && data.success) {
        if (data.testMode) {
          this.addOutput(
            "test-mode",
            `TEST MODE: Reply validated but not sent.\nWould have gone to: ${data.emailDetails?.to}`,
            { emailDetails: data.emailDetails }
          );
        } else {
          this.addOutput(
            "email-sent",
            `Reply sent successfully.\n  To: ${data.emailDetails?.to}\n  Message ID: ${data.messageId}`,
            { messageId: data.messageId, emailDetails: data.emailDetails }
          );
        }
        return data;
      }

      this.addOutput("error", `Failed to send reply: ${data.error}`);
      throw new Error(data.error || "Send failed.");
    } catch (err) {
      this.addOutput("error", `Send error: ${err.message}`);
      throw err;
    }
  }

  async sendNewEmail(to, subject, body) {
    await this.ensureGmailConnected();
    this.addOutput("log", `Composing new email to ${to}...`);

    try {
      const response = await fetch(
        "http://localhost:3001/api/emails/send-new",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ to, subject, body }),
        }
      );

      const data = await response.json();

      if (response.ok && data.success) {
        if (data.testMode) {
          this.addOutput(
            "test-mode",
            `TEST MODE: New email validated but not sent.\nTo: ${data.emailDetails?.to}\nSubject: ${data.emailDetails?.subject}`,
            { emailDetails: data.emailDetails }
          );
        } else {
          this.addOutput(
            "email-sent",
            `New email sent successfully.\n  To: ${data.emailDetails?.to}\n  Subject: ${data.emailDetails?.subject}\n  Message ID: ${data.messageId}`,
            { messageId: data.messageId, emailDetails: data.emailDetails }
          );
        }
        return data;
      }

      this.addOutput("error", `Failed to send email: ${data.error}`);
      throw new Error(data.error || "Send failed.");
    } catch (err) {
      this.addOutput("error", `Send new email error: ${err.message}`);
      throw err;
    }
  }

  // -------------------------------------------------------------------------
  // GMAIL — MODIFY
  // -------------------------------------------------------------------------

  async markEmailAsRead(emailId) {
    await this.ensureGmailConnected();

    try {
      const response = await fetch(
        "http://localhost:3001/api/emails/markread",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ emailId }),
        }
      );

      const data = await response.json();

      if (response.ok) {
        this.addOutput("log", "Email marked as read.");
        return true;
      }

      this.addOutput("warning", `Could not mark email as read: ${data.error}`);
      return false;
    } catch (err) {
      this.addOutput("warning", `Mark as read error: ${err.message}`);
      return false;
    }
  }

  async archiveEmail(emailId) {
    await this.ensureGmailConnected();

    try {
      const response = await fetch("http://localhost:3001/api/emails/archive", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ emailId }),
      });

      const data = await response.json();

      if (response.ok) {
        this.addOutput("log", "Email archived.");
        return true;
      }

      this.addOutput("warning", `Could not archive email: ${data.error}`);
      return false;
    } catch (err) {
      this.addOutput("warning", `Archive error: ${err.message}`);
      return false;
    }
  }

  // -------------------------------------------------------------------------
  // GENERAL AI
  // -------------------------------------------------------------------------

  async callAI(input, task) {
    this.addOutput("log", `Calling AI: ${(task || "").substring(0, 60)}...`);

    try {
      const response = await fetch("http://localhost:3001/api/ai", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ input, task }),
      });

      const data = await response.json();

      if (response.ok && data.text) {
        this.addOutput("ai-result", `AI result:\n${data.text}`, {
          result: data.text,
        });
        return data.text;
      }

      this.addOutput("error", `AI call failed: ${data.error}`);
      throw new Error(data.error || "AI call failed.");
    } catch (err) {
      this.addOutput("error", `AI error: ${err.message}`);
      throw err;
    }
  }

  // -------------------------------------------------------------------------
  // EXECUTE
  // Runs the Blockly-generated code inside a sandboxed async function.
  // -------------------------------------------------------------------------

  async execute(code, onOutputCallback) {
    this.output = [];
    this.onOutput = onOutputCallback;

    this.addOutput("log", "Starting workflow...");

    try {
      await this.checkGmailConnection();

      const context = {
        inputData: this.variables,

        // Basic output
        output: (msg) => this.addOutput("result", String(msg)),
        log: (msg) => this.addOutput("log", String(msg)),

        // Gmail — read
        fetchEmails: async (max) => {
          try {
            return await this.fetchUnreadEmails(max);
          } catch (err) {
            this.addOutput("error", `fetchEmails: ${err.message}`);
            return [];
          }
        },
        searchEmails: async (query, max) => {
          try {
            return await this.searchEmails(query, max);
          } catch (err) {
            this.addOutput("error", `searchEmails: ${err.message}`);
            return [];
          }
        },

        // Gmail — send
        generateReply: async (body, task, subject, from) => {
          try {
            return await this.generateAIReply(body, task, subject, from);
          } catch (err) {
            this.addOutput("error", `generateReply: ${err.message}`);
            return "";
          }
        },
        sendReply: async (emailId, replyBody, subject, to, threadId) => {
          try {
            return await this.sendEmailReply(
              emailId,
              replyBody,
              subject,
              to,
              threadId
            );
          } catch (err) {
            this.addOutput("error", `sendReply: ${err.message}`);
            throw err;
          }
        },
        sendNewEmail: async (to, subject, body) => {
          try {
            return await this.sendNewEmail(to, subject, body);
          } catch (err) {
            this.addOutput("error", `sendNewEmail: ${err.message}`);
            throw err;
          }
        },

        // Gmail — modify
        markRead: async (emailId) => {
          try {
            return await this.markEmailAsRead(emailId);
          } catch (err) {
            this.addOutput("warning", `markRead: ${err.message}`);
            return false;
          }
        },
        archiveEmail: async (emailId) => {
          try {
            return await this.archiveEmail(emailId);
          } catch (err) {
            this.addOutput("warning", `archiveEmail: ${err.message}`);
            return false;
          }
        },

        // AI
        callAI: async (input, task) => {
          try {
            return await this.callAI(input, task);
          } catch (err) {
            this.addOutput("error", `callAI: ${err.message}`);
            return "";
          }
        },

        // Variables
        setVariable: (name, value) => {
          this.variables[name] = value;
          this.addOutput("log", `Variable set: ${name}`);
        },
        getVariable: (name) => this.variables[name],

        // Utility
        delay: (seconds) =>
          new Promise((resolve) => {
            this.addOutput("log", `Waiting ${seconds} second(s)...`);
            setTimeout(resolve, seconds * 1000);
          }),
      };

      const AsyncFunction = Object.getPrototypeOf(
        async function () {}
      ).constructor;

      const wrapped = `
try {
  ${code}
} catch (error) {
  context.log("Error in workflow: " + error.message);
  throw error;
}
`;
      const executor = new AsyncFunction("context", wrapped);
      await executor(context);

      this.addOutput("success", "Workflow completed successfully.");

      return {
        success: true,
        output: this.output,
        message: "Workflow completed.",
      };
    } catch (error) {
      this.addOutput("error", `Execution error: ${error.message}`);
      if (error.stack) console.error("[engine] Stack:", error.stack);

      return {
        success: false,
        error: error.message,
        output: this.output,
        message: "Workflow failed.",
      };
    }
  }
}

// ---------------------------------------------------------------------------
// SAMPLE DATA (used when running templates in dev / demo mode)
// ---------------------------------------------------------------------------

export const sampleData = {
  customerEmail: `Hi Support Team,

I ordered product #12345 last week but haven't received any shipping confirmation.
Can you please check the status of my order?

Thanks,
John Smith`,

  salesData: `Q4 Sales Report:
Region A: $125,000
Region B: $98,000
Region C: $156,000
Total: $379,000

Growth: +15% vs Q3`,

  technicalIssue: `System Error Log:
Error: Connection timeout
Timestamp: 2024-01-15 14:30:22
Service: payment-gateway
Severity: HIGH`,
};

export function getSampleDataForAgent(agentType) {
  switch (agentType) {
    case "support":
      return { emailBody: sampleData.customerEmail };
    case "sales":
      return { reportData: sampleData.salesData };
    case "data":
      return { logData: sampleData.technicalIssue };
    case "email":
      return {};
    default:
      return sampleData;
  }
}

// ---------------------------------------------------------------------------
// WORKFLOW TEMPLATES (metadata only — block layout is built in Builder.jsx)
// ---------------------------------------------------------------------------

export const workflowTemplates = {
  customerSupport: {
    name: "Customer Support Agent",
    description: "Analyses customer emails and drafts helpful responses.",
    agentType: "support",
    requiresGmail: false,
  },
  salesReport: {
    name: "Sales Report Generator",
    description: "Processes sales data and generates executive summaries.",
    agentType: "sales",
    requiresGmail: false,
  },
  gmailAutoReply: {
    name: "Gmail Auto-Reply Agent",
    description: "Fetches unread emails and sends AI-generated replies.",
    agentType: "email",
    requiresGmail: true,
  },
  gmailDigest: {
    name: "Inbox Digest",
    description: "Searches inbox and generates a summary of all emails.",
    agentType: "email",
    requiresGmail: true,
  },
};
